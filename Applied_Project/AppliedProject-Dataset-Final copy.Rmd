---
title: "CRQA-Sample-Dataset"
output: pdf_document
date: "2024-09-23"
---

```{r}
install.packages("crqa", type = "binary")
install.packages("plyr")
install.packages("rMEA")
install.packages("zoo")
```

```{r setup, include=FALSE}
library(plyr)
library(crqa)
library(dplyr)
library(rMEA)
library(zoo)
library(tseriesChaos)
library(ggplot2)
```

```{r MEA}
mea_normal <- readMEA("/Users/gabrielleyoung/Desktop/DataAP/TxtFiles_cleaned", sampRate = 25, s1Col = 2, s2Col = 1,
                     s1Name = "Participant2", s2Name = "Participant1", skip=1,
                     idOrder = c("id","session"), idSep="_")
```

```{r example-dyads}
diagnosticPlot(mea_normal[[1]])
diagnosticPlot(mea_normal[[2]])
diagnosticPlot(mea_normal[[3]])
diagnosticPlot(mea_normal[[4]])
diagnosticPlot(mea_normal[[5]])
```

# ```{r sample-parameters-crqa} 
# # make to run for ALL rows
# delay <- 1
# embed <- 1
# radius <- 0.3  # Larger radius
# mindiagline <- 2  # Lower mindiagline
# minvertline <- 2 
# rescale <- 0
# normalize <- 0
# tw = 0; whiteline = FALSE; recpt = FALSE; side = "both"
# method = 'mdcrqa'; metric = 'euclidean';  
# datatype = "continuous"
# ```

```{r sample-dataset}
dyad101_data <- mea_normal[[1]]

# Assuming the dataframe has columns for two participants
dyad101_data2 <- dyad101_data[[1]]
ts_participant1 <- dyad101_data2$Participant1  # Time series for Participant 1
ts_participant2 <- dyad101_data2$Participant2 

ts_participant1s <- ts_participant1[4610:13829]
ts_participant2s <- ts_participant2[4610:13829]

# ts_participant1_smoothed <- rollmean(ts_participant1_small, k = 5, fill = NA, align = "center")
# ts_participant2_smoothed <- rollmean(ts_participant2_small, k = 5, fill = NA, align = "center")
# 
# # Clean any remaining NA values
# ts_participant1_clean <- na.omit(ts_participant1_smoothed)
# ts_participant2_clean <- na.omit(ts_participant2_smoothed)
# 
# # Convert to matrices
# ts_participant1_matrix_small <- matrix(ts_participant1_clean, ncol = 1)
# ts_participant2_matrix_small <- matrix(ts_participant2_clean, ncol = 1)

#ans <- crqa(ts_participant1_matrix_small, ts_participant2_matrix_small, delay, embed, rescale, radius, normalize,
         #   mindiagline, minvertline, tw, whiteline, recpt, side, method, metric, datatype)

# print(ans)
# RP <- ans$RP
# RP_matrix <- as.matrix(RP)
# image(RP_matrix, main = "Recurrence Plot Dyad 1000")
# results <- unlist(ans[1:10])
# print(results)
```
# DETERMINE PARAMETERS
```{r determine-parameters}
cross_theiler_window = 0
cross_rescale_type = 'mean'
# rec_rescale_type = 'max'
```

```{r determine-delay}
cross_ami_p1 = mutual(ts_participant1s,
                 lag.max = 800)

cross_ami_p2 = mutual(ts_participant2s,
                     lag.max = 800)


find_first_minimum <- function(ami_values) {
  for (i in 2:(length(ami_values) - 1)) {
    if (ami_values[i] < ami_values[i - 1] && ami_values[i] < ami_values[i + 1]) {
      return(i)  # Return the lag corresponding to the first local minimum
    }
  }
  return(NULL)  # Return NULL if no minimum is found
}

# Apply the function to both participants
chosen_delay_p1 = find_first_minimum(cross_ami_p1)
chosen_delay_p2 = find_first_minimum(cross_ami_p2)

cross_chosen_delay = round(mean(c(chosen_delay_p1, chosen_delay_p2)))

cross_remaining_mutual_info_p1 = cross_ami_p1[cross_chosen_delay]
cross_remaining_mutual_info_p2 = cross_ami_p2[cross_chosen_delay]
```

```{r determine-embedding-d}
# so what i am going to do is do this for x amount of dyads and find the average across all of these
cross_max_embedding = 10
cross_fnn_p1 = false.nearest(ts_participant1s,
                            m = cross_max_embedding,
                            d = cross_chosen_delay,
                            t = cross_theiler_window)

# determine embedding
cross_fnn_p2 = false.nearest(ts_participant2s,
                            m = cross_max_embedding,
                            d = cross_chosen_delay,
                            t = cross_theiler_window)
plot(cross_fnn_p1)
plot(cross_fnn_p2)

cross_chosen_embedding = 5
cross_remaining_fnn_p1 = cross_fnn_p1[cross_chosen_embedding]
cross_remaining_fnn_p2 = cross_fnn_p2[cross_chosen_embedding]
```

```{r select-radius}
if (cross_rescale_type == 'mean'){
  rescaled_p1 = ts_participant1s / mean(ts_participant1s)
  rescaled_p2 = ts_participant2s / mean(ts_participant2s)
} else if (cross_rescale_type == 'max'){
  rescaled_p1 = ts_participant1s / max(ts_participant1s)
  rescaled_p2 = ts_participant2s / max(ts_participant2s)
}
```

```{r run-crqa}
crqa_analysis = crqa(ts1 = rescaled_p1, 
                    ts2 = rescaled_p2,
                    delay = cross_chosen_delay, 
                    embed = cross_chosen_embedding, 
                    r = .1, # you can keep playing with this to find something that works
                    normalize = 0, 
                    rescale = 0, # distance matrix rescaling option -- see documentation
                    mindiagline = 2,
                    minvertline = 2, 
                    tw = cross_theiler_window, 
                    whiteline = FALSE,
                    recpt=FALSE)
```

#RESULTS FOR CRQA SAMPLE
```{r}
crqa_analysis$RR # rate of recurrence
crqa_analysis$DET # % determinism
crqa_analysis$NRLINE # total number of lines on the plot
crqa_analysis$maxL # maximum line length on plot
crqa_analysis$L # average line length on plot
crqa_analysis$ENTR # entropy
crqa_analysis$rENTR # normalized entropy
crqa_analysis$LAM # laminarity
crqa_analysis$TT # trapping time
```

```{r plot-it}
par = list(unit = 2, 
           labelx = "x-axis movement", 
           labely = "y-axis movement", 
           cols = "red", 
           pcex = 1)
plotRP(crqa_analysis$RP, par)
```
```{r}
crqa_df = data.frame(points = crqa_analysis$RP@i,
                           loc = seq_along(crqa_analysis$RP@i))
ggplot(crqa_df,aes(x=points,
                        y=loc)) +
  geom_point(color="black",size=.01) +
  theme_classic() +
  theme(legend.position="none", axis.text.x = element_blank(), axis.text.y = element_blank()) +
  ylab("Participant 2") + xlab("Participant 1") +
  ggtitle("Cross-recurrence plot between\nParticipant 1 and Participant 2 Movement in Survivor Task")
```

```{r sample-to-select-parameters}
find_elbow <- function(fnn_values) {
  # Remove NA or Inf values from FNN values
  fnn_values <- fnn_values[is.finite(fnn_values)]
  
  # Calculate the difference between successive FNN values
  differences <- diff(fnn_values)
  
  # Loop through the differences to find the point of maximum curvature (the elbow)
  for (i in 2:(length(differences) - 2)) {
    if (!is.na(differences[i]) && !is.na(differences[i + 1]) &&
        differences[i] > differences[i + 1] && differences[i + 1] < differences[i + 2]) {
      return(i + 1)  # Return the embedding dimension at the elbow
    }
  }
  return(length(fnn_values))  # If no clear elbow is found, return the max embedding
}
# Randomly sample 5 dyads
set.seed(123)  # Set seed for reproducibility
dyads_to_sample <- sample(1:length(mea_normal), 5)

# Initialize storage for delay and embedding dimensions
delays <- c()
embeddings <- c()

for (i in 1:length(dyads_to_sample)) {
  # Select the dyad
  dyad_data <- mea_normal[[dyads_to_sample[i]]][[1]]
  
  # Extract participant time series
  ts_participant1 <- dyad_data$Participant1
  ts_participant2 <- dyad_data$Participant2
  
  # Select the middle 60% of the time series
  ts_length <- length(ts_participant1)
  start_idx <- floor(0.2 * ts_length) + 1
  end_idx <- floor(0.8 * ts_length)
  ts_participant1s <- ts_participant1[start_idx:end_idx]
  ts_participant2s <- ts_participant2[start_idx:end_idx]
  
  # Determine delay using AMI
  cross_ami_p1 <- mutual(ts_participant1s, lag.max = 800)
  cross_ami_p2 <- mutual(ts_participant2s, lag.max = 800)
  
  chosen_delay_p1 <- find_first_minimum(cross_ami_p1)
  chosen_delay_p2 <- find_first_minimum(cross_ami_p2)
  cross_chosen_delay <- round(mean(c(chosen_delay_p1, chosen_delay_p2)))
  delays <- c(delays, cross_chosen_delay)
  
  # Determine embedding dimension using FNN and find the elbow
  cross_max_embedding <- 10
  cross_fnn_p1 <- false.nearest(ts_participant1s, m = cross_max_embedding, d = cross_chosen_delay, t = 0)
  cross_fnn_p2 <- false.nearest(ts_participant2s, m = cross_max_embedding, d = cross_chosen_delay, t = 0)
  
  elbow_p1 <- find_elbow(cross_fnn_p1)
  elbow_p2 <- find_elbow(cross_fnn_p2)
  cross_chosen_embedding <- round(mean(c(elbow_p1, elbow_p2)))
  embeddings <- c(embeddings, cross_chosen_embedding)
  
  # Optionally, plot FNN or AMI here to visualize for each dyad
  plot(cross_fnn_p1, type = "b", main = paste("Dyad", dyads_to_sample[i], "- FNN P1"))
  plot(cross_fnn_p2, type = "b", main = paste("Dyad", dyads_to_sample[i], "- FNN P2"))
}

# Calculate the average delay and embedding dimension
average_delay <- round(mean(delays, na.rm = TRUE))
average_embedding <- round(mean(embeddings, na.rm = TRUE))

cat("Average Delay: ", average_delay, "\n")
cat("Average Embedding: ", average_embedding, "\n")
```

```{r function-for-all-data}
# Function to extract the middle 60% of the time series
get_middle_60_percent <- function(time_series) {
  total_length <- length(time_series)
  start_index <- floor(0.2 * total_length) + 1
  end_index <- ceiling(0.8 * total_length)
  return(time_series[start_index:end_index])
}
```

<!-- ```{r run-all-dyads} -->
<!-- dyad101_data <- mea_normal[[2]] -->

<!-- # Assuming the dataframe has columns for two participants -->
<!-- dyad101_data2 <- dyad101_data[[2]] -->
<!-- ts_participant1 <- dyad101_data2$Participant1  # Time series for Participant 1 -->
<!-- ts_participant2 <- dyad101_data2$Participant2  -->

<!-- ts_participant1s <- get_middle_60_percent(ts_participant1) -->
<!-- ts_participant2s <- get_middle_60_percent(ts_participant2) -->


<!-- if (cross_rescale_type == 'mean'){ -->
<!--   rescaled_p1 = ts_participant1s / mean(ts_participant1s) -->
<!--   rescaled_p2 = ts_participant2s / mean(ts_participant2s) -->
<!-- } else if (cross_rescale_type == 'max'){ -->
<!--   rescaled_p1 = ts_participant1s / max(ts_participant1s) -->
<!--   rescaled_p2 = ts_participant2s / max(ts_participant2s) -->
<!-- } -->

<!-- #run analysis for all dayds -->
<!-- crqa_analysis17 = crqa(ts1 = rescaled_p1,  -->
<!--                     ts2 = rescaled_p2, -->
<!--                     delay = average_delay,  -->
<!--                     embed = average_embedding,  -->
<!--                     r = .1, # you can keep playing with this to find something that works -->
<!--                     normalize = 0,  -->
<!--                     rescale = 0, # distance matrix rescaling option -- see documentation -->
<!--                     mindiagline = 2, -->
<!--                     minvertline = 2,  -->
<!--                     tw = cross_theiler_window,  -->
<!--                     whiteline = FALSE, -->
<!--                     recpt=FALSE) -->
<!-- ``` -->
```{r}
library(readr)
```

```{r run-in-batches}
# Function to extract the middle 60% of the time series
get_middle_60_percent <- function(time_series) {
  total_length <- length(time_series)
  start_index <- floor(0.2 * total_length) + 1
  end_index <- ceiling(0.8 * total_length)
  return(time_series[start_index:end_index])
}
```

```{r}
MEA_folder_path_sample <- "/Users/gabrielleyoung/Desktop/DataAP/Sample_individual_files1"

txt_files <- list.files(path = MEA_folder_path_sample, pattern = "\\.txt$", full.names = TRUE)

df_list <- list()

# Loop through each file and read it into a data frame
for (file in txt_files) {
    # Read the .txt file as a DataFrame (adjust delimiter if necessary)
    df <- read_delim(file, delim = "\t", col_names = FALSE)  # adjust delimiter if necessary
    
    # Optionally, store each DataFrame in the list with the file name as the key
    base_name <- tools::file_path_sans_ext(basename(file))
    df_list[[base_name]] <- df  # Save as df with the file name as the list element key
    
    # Print the first few rows of the DataFrame
    print(paste("Data from file:", base_name))
    print(head(df))
}
```

```{r}
# Define the function to process each dyad and run CRQA
run_crqa_for_dyads <- function(df_list, cross_rescale_type, average_delay, average_embedding, cross_theiler_window) {
  
  # Create an empty list to store results
  crqa_results <- list()
  
  # Loop through each dyad in df_list
  for (dyad_name in names(df_list)) {
    
    # Check if the current dyad has both Participant 1 and Participant 2 time series
    if (grepl("Participant1", dyad_name)) {
      # Extract time series for Participant 1 and Participant 2
      ts_participant1 <- df_list[[dyad_name]]  # e.g., Dyad1000_Participant1_MEA
      ts_participant2 <- df_list[[gsub("Participant1", "Participant2", dyad_name)]]  # e.g., Dyad1000_Participant2_MEA

      # Convert lists to numeric vectors
      ts_participant1s <- unlist(ts_participant1)
      ts_participant1s <- as.numeric(ts_participant1s)
      ts_participant2s <- unlist(ts_participant2)
      ts_participant2s <- as.numeric(ts_participant2s)
      
      # Get middle 60 percent of the time series
      ts_participant1s <- get_middle_60_percent(ts_participant1s)
      ts_participant2s <- get_middle_60_percent(ts_participant2s)
      
      # Cross-rescaling based on the provided option
      if (cross_rescale_type == 'mean') {
        rescaled_p1 <- ts_participant1s / mean(ts_participant1s)
        rescaled_p2 <- ts_participant2s / mean(ts_participant2s)
      } else if (cross_rescale_type == 'max') {
        rescaled_p1 <- ts_participant1s / max(ts_participant1s)
        rescaled_p2 <- ts_participant2s / max(ts_participant2s)
      }
      
      # Perform the CRQA analysis
      crqa_analysis <- crqa(ts1 = rescaled_p1,
                            ts2 = rescaled_p2,
                            delay = average_delay,
                            embed = average_embedding,
                            r = 0.1,
                            normalize = 0,
                            rescale = 0,
                            mindiagline = 2,
                            minvertline = 2,
                            tw = cross_theiler_window,
                            whiteline = FALSE,
                            recpt = FALSE)
      
      # Extract the desired results from the CRQA analysis
      crqa_results[[dyad_name]] <- list(
        RR = crqa_analysis$RR,
        DET = crqa_analysis$DET,
        NRLINE = crqa_analysis$NRLINE,
        maxL = crqa_analysis$maxL,
        L = crqa_analysis$L,
        ENTR = crqa_analysis$ENTR,
        rENTR = crqa_analysis$rENTR,
        LAM = crqa_analysis$LAM,
        TT = crqa_analysis$TT
      )
    }
  }
  
  return(crqa_results)
}
```

```{r}
results <- run_crqa_for_dyads(df_list,cross_rescale_type, average_delay, average_embedding, cross_theiler_window)

print(results)
```


```{r}
MEA_folder_path_sample <- "/Users/gabrielleyoung/Desktop/DataAP/Sample_individual_files3"

txt_files <- list.files(path = MEA_folder_path_sample, pattern = "\\.txt$", full.names = TRUE)

df_list <- list()

# Loop through each file and read it into a data frame
for (file in txt_files) {
    # Read the .txt file as a DataFrame (adjust delimiter if necessary)
    df <- read_delim(file, delim = "\t", col_names = FALSE)  # adjust delimiter if necessary
    
    # Optionally, store each DataFrame in the list with the file name as the key
    base_name <- tools::file_path_sans_ext(basename(file))
    df_list[[base_name]] <- df  # Save as df with the file name as the list element key
    
    # Print the first few rows of the DataFrame
    print(paste("Data from file:", base_name))
    print(head(df))
}
```


```{r}
results3 <- run_crqa_for_dyads(df_list,cross_rescale_type, average_delay, average_embedding, cross_theiler_window)

print(results3)
```

```{r}
merged_results <- cbind(results, results3)
```

```{r}
library(dplyr)
library(purrr)

# Function to convert a list of metrics into a dataframe
convert_to_df <- function(results_list) {
  map_dfr(names(results_list), function(dyad_name) {
    # Extract the metrics for the current dyad
    metrics <- results_list[[dyad_name]]
    
    # Create a data frame for this dyad
    data.frame(
      Dyad = gsub("_Participant1_MEA", "", dyad_name), # Remove suffix to clean dyad name
      RR = metrics$RR,
      DET = metrics$DET,
      NRLINE = metrics$NRLINE,
      maxL = metrics$maxL,
      L = metrics$L,
      ENTR = metrics$ENTR,
      rENTR = metrics$rENTR,
      LAM = metrics$LAM,
      TT = metrics$TT,
      stringsAsFactors = FALSE
    )
  })
}

# Convert each results list into a dataframe
results_df <- convert_to_df(results)
results3_df <- convert_to_df(results3)

# Merge the two dataframes by "Dyad"
merged_results <- full_join(results_df, results3_df, by = "Dyad", suffix = c("_results", "_results3"))

# View the merged dataframe
print(merged_results)

# Save the merged dataframe as a CSV file
write.csv(merged_results, "merged_results.csv", row.names = FALSE)

# Confirmation message
cat("Merged results saved as 'merged_results.csv' in the working directory.")
```

```{r}
MEA_folder_path_sample <- "/Users/gabrielleyoung/Desktop/DataAP/Sample_individual_files5"

txt_files <- list.files(path = MEA_folder_path_sample, pattern = "\\.txt$", full.names = TRUE)

df_list <- list()

# Loop through each file and read it into a data frame
for (file in txt_files) {
    # Read the .txt file as a DataFrame (adjust delimiter if necessary)
    df <- read_delim(file, delim = "\t", col_names = FALSE)  # adjust delimiter if necessary
    
    # Optionally, store each DataFrame in the list with the file name as the key
    base_name <- tools::file_path_sans_ext(basename(file))
    df_list[[base_name]] <- df  # Save as df with the file name as the list element key
    
    # Print the first few rows of the DataFrame
    print(paste("Data from file:", base_name))
    print(head(df))
}
```


```{r}
results5 <- run_crqa_for_dyads(df_list,cross_rescale_type, average_delay, average_embedding, cross_theiler_window)

print(results5)
```


```{r}
MEA_folder_path_sample <- "/Users/gabrielleyoung/Desktop/DataAP/Sample_individual_files7"

txt_files <- list.files(path = MEA_folder_path_sample, pattern = "\\.txt$", full.names = TRUE)

df_list <- list()

# Loop through each file and read it into a data frame
for (file in txt_files) {
    # Read the .txt file as a DataFrame (adjust delimiter if necessary)
    df <- read_delim(file, delim = "\t", col_names = FALSE)  # adjust delimiter if necessary
    
    # Optionally, store each DataFrame in the list with the file name as the key
    base_name <- tools::file_path_sans_ext(basename(file))
    df_list[[base_name]] <- df  # Save as df with the file name as the list element key
    
    # Print the first few rows of the DataFrame
    print(paste("Data from file:", base_name))
    print(head(df))
}
```


```{r}
results7 <- run_crqa_for_dyads(df_list,cross_rescale_type, average_delay, average_embedding, cross_theiler_window)

print(results7)
```

```{r}
MEA_folder_path_sample <- "/Users/gabrielleyoung/Desktop/DataAP/Sample_individual_files8"

txt_files <- list.files(path = MEA_folder_path_sample, pattern = "\\.txt$", full.names = TRUE)

df_list <- list()

# Loop through each file and read it into a data frame
for (file in txt_files) {
    # Read the .txt file as a DataFrame (adjust delimiter if necessary)
    df <- read_delim(file, delim = "\t", col_names = FALSE)  # adjust delimiter if necessary
    
    # Optionally, store each DataFrame in the list with the file name as the key
    base_name <- tools::file_path_sans_ext(basename(file))
    df_list[[base_name]] <- df  # Save as df with the file name as the list element key
    
    # Print the first few rows of the DataFrame
    print(paste("Data from file:", base_name))
    print(head(df))
}
```


```{r}
results8 <- run_crqa_for_dyads(df_list,cross_rescale_type, average_delay, average_embedding, cross_theiler_window)

print(results8)
```

# ```{r}
# MEA_folder_path <- "/Users/gabrielleyoung/Desktop/DataAP/Individual_MEA_Files"
# 
# txt_files <- list.files(path = MEA_folder_path, pattern = "\\.txt$", full.names = TRUE)
# 
# df_list <- list()
# 
# # Loop through each file and read it into a data frame
# for (file in txt_files) {
#     # Read the .txt file as a DataFrame (adjust delimiter if necessary)
#     df <- read_delim(file, delim = "\t", col_names = FALSE)  # adjust delimiter if necessary
#     
#     # Optionally, store each DataFrame in the list with the file name as the key
#     base_name <- tools::file_path_sans_ext(basename(file))
#     df_list[[base_name]] <- df  # Save as df with the file name as the list element key
#     
#     # Print the first few rows of the DataFrame
#     print(paste("Data from file:", base_name))
#     print(head(df))
# }
# ```

<!-- ```{r} -->
<!-- ts_participant1 <- df_list$Dyad1000_Participant1_MEA # Time series for Participant 1 -->
<!-- ts_participant2 <- df_list$Dyad1000_Participant2_MEA -->

<!-- ts_participant1s <- unlist(ts_participant1)  # Converts list to vector -->
<!-- ts_participant1s <- as.numeric(ts_participant1s)  # Now convert to numeric -->
<!-- ts_participant2s <- unlist(ts_participant2) -->
<!-- ts_participant2s <- as.numeric(ts_participant2s) -->

<!-- ts_participant1s <- get_middle_60_percent(ts_participant1s) -->
<!-- ts_participant2s <- get_middle_60_percent(ts_participant2s) -->

<!-- if (cross_rescale_type == 'mean'){ -->
<!--   rescaled_p1 = ts_participant1s / mean(ts_participant1s) -->
<!--   rescaled_p2 = ts_participant2s / mean(ts_participant2s) -->
<!-- } else if (cross_rescale_type == 'max'){ -->
<!--   rescaled_p1 = ts_participant1s / max(ts_participant1s) -->
<!--   rescaled_p2 = ts_participant2s / max(ts_participant2s) -->
<!-- } -->

<!-- #run analysis for all dayds -->
<!-- crqa_analysis_1000 = crqa(ts1 = rescaled_p1,  -->
<!--                     ts2 = rescaled_p2, -->
<!--                     delay = average_delay,  -->
<!--                     embed = average_embedding,  -->
<!--                     r = .1, # you can keep playing with this to find something that works -->
<!--                     normalize = 0,  -->
<!--                     rescale = 0, # distance matrix rescaling option -- see documentation -->
<!--                     mindiagline = 2, -->
<!--                     minvertline = 2,  -->
<!--                     tw = cross_theiler_window,  -->
<!--                     whiteline = FALSE, -->
<!--                     recpt=FALSE) -->
<!-- ``` -->

```{r}
crqa_analysis_1000$RR # rate of recurrence
crqa_analysis_1000$DET # % determinism
crqa_analysis_1000$NRLINE # total number of lines on the plot
```

#```{r}
# Define the function to process each dyad and run CRQA
run_crqa_for_dyads <- function(df_list, cross_rescale_type, average_delay, average_embedding, cross_theiler_window) {
  
  # Create an empty list to store results
  crqa_results <- list()
  
  # Loop through each dyad in df_list
  for (dyad_name in names(df_list)) {
    
    # Check if the current dyad has both Participant 1 and Participant 2 time series
    if (grepl("Participant1", dyad_name)) {
      # Extract time series for Participant 1 and Participant 2
      ts_participant1 <- df_list[[dyad_name]]  # e.g., Dyad1000_Participant1_MEA
      ts_participant2 <- df_list[[gsub("Participant1", "Participant2", dyad_name)]]  # e.g., Dyad1000_Participant2_MEA

      # Convert lists to numeric vectors
      ts_participant1s <- unlist(ts_participant1)
      ts_participant1s <- as.numeric(ts_participant1s)
      ts_participant2s <- unlist(ts_participant2)
      ts_participant2s <- as.numeric(ts_participant2s)
      
      # Get middle 60 percent of the time series
      ts_participant1s <- get_middle_60_percent(ts_participant1s)
      ts_participant2s <- get_middle_60_percent(ts_participant2s)
      
      # Cross-rescaling based on the provided option
      if (cross_rescale_type == 'mean') {
        rescaled_p1 <- ts_participant1s / mean(ts_participant1s)
        rescaled_p2 <- ts_participant2s / mean(ts_participant2s)
      } else if (cross_rescale_type == 'max') {
        rescaled_p1 <- ts_participant1s / max(ts_participant1s)
        rescaled_p2 <- ts_participant2s / max(ts_participant2s)
      }
      
      # Perform the CRQA analysis
      crqa_analysis <- crqa(ts1 = rescaled_p1,
                            ts2 = rescaled_p2,
                            delay = average_delay,
                            embed = average_embedding,
                            r = 0.1,
                            normalize = 0,
                            rescale = 0,
                            mindiagline = 2,
                            minvertline = 2,
                            tw = cross_theiler_window,
                            whiteline = FALSE,
                            recpt = FALSE)
      
      # Extract the desired results from the CRQA analysis
      crqa_results[[dyad_name]] <- list(
        RR = crqa_analysis$RR,
        DET = crqa_analysis$DET,
        NRLINE = crqa_analysis$NRLINE,
        maxL = crqa_analysis$maxL,
        L = crqa_analysis$L,
        ENTR = crqa_analysis$ENTR,
        rENTR = crqa_analysis$rENTR,
        LAM = crqa_analysis$LAM,
        TT = crqa_analysis$TT
      )
    }
  }
  
  return(crqa_results)
}
#```

```{r}
results <- run_crqa_for_dyads(df_list,cross_rescale_type, average_delay, average_embedding, cross_theiler_window)

# Access the results for a specific dyad, e.g., Dyad1000
results$Dyad1000_Participant1_MEA
```

```{r}
# Function to process one dyad and run CRQA
run_crqa_for_dyad <- function(dyad_data, dyad_name, average_embedding, average_delay) {
  # Extract dyad number
  dyad_number <- gsub("all_MEA_", "", dyad_name)

  # Extract time series for both participants
  ts_participant1 <- dyad_data[[1]]$Participant1
  ts_participant2 <- dyad_data[[1]]$Participant2

  # Extract the middle 60% of the data
  ts_participant1_middle <- get_middle_60_percent(ts_participant1)
  ts_participant2_middle <- get_middle_60_percent(ts_participant2)

  # Run CRQA
  crqa_analysis <- crqa(ts1 = ts_participant1_middle, 
                        ts2 = ts_participant2_middle,
                        delay = average_delay,          
                        embed = average_embedding,      
                        r = 0.1,                        
                        normalize = 0, 
                        rescale = 0, 
                        mindiagline = 2, 
                        minvertline = 2, 
                        tw = 0,                         
                        whiteline = FALSE, 
                        recpt = FALSE)

  # Return results as a named vector
  results <- c(dyad_number = dyad_number, unlist(crqa_analysis[1:10]))
  return(results)
}
```



```{r}
# Function to process one dyad and run CRQA
run_crqa_for_dyad <- function(dyad_data, dyad_name, average_embedding, average_delay) {
  # Extract dyad number
  dyad_number <- gsub("all_MEA_", "", dyad_name)

  # Extract and clean time series
  ts_participant1 <- na.omit(as.numeric(dyad_data[[1]]$Participant1))
  ts_participant2 <- na.omit(as.numeric(dyad_data[[1]]$Participant2))

  # Extract the middle 60% of the data
  ts_participant1_middle <- get_middle_60_percent(ts_participant1)
  ts_participant2_middle <- get_middle_60_percent(ts_participant2)

  # Run CRQA
  crqa_analysis <- crqa(ts1 = ts_participant1_middle, 
                        ts2 = ts_participant2_middle,
                        delay = average_delay,          
                        embed = average_embedding,      
                        r = 0.1,                        
                        normalize = 0, 
                        rescale = 0, 
                        mindiagline = 2, 
                        minvertline = 2, 
                        tw = 0,                         
                        whiteline = FALSE, 
                        recpt = FALSE)

  # Return results as a named vector
  results <- c(dyad_number = dyad_number, unlist(crqa_analysis[1:10]))
  return(results)
}

# Function to run analysis dyad by dyad (avoiding large memory loads)
run_analysis_for_dyads <- function(mea_normal, average_embedding, average_delay, output_file = "crqa_results.csv") {
  # Write header to the output file
  write.csv(data.frame(), output_file, row.names = FALSE)  # Initialize file
  
  # Process each dyad one by one to save memory
  for (i in seq_along(mea_normal)) {
    dyad_name <- names(mea_normal)[i]  # Get dyad name
    dyad_data <- mea_normal[[i]]      # Access dyad data
    
    # Print progress
    cat("Processing dyad", dyad_name, "(", i, "of", length(mea_normal), ")\n")
    
    # Run CRQA for the current dyad
    tryCatch({
      results <- run_crqa_for_dyad(dyad_data, dyad_name, average_embedding, average_delay)
      results_df <- as.data.frame(t(results))  # Transpose to save as row
      
      # Append results to CSV immediately to avoid memory buildup
      write.table(results_df, output_file, sep = ",", append = TRUE, col.names = !file.exists(output_file), row.names = FALSE)
    }, error = function(e) {
      cat("Error in dyad", dyad_name, ": ", e$message, "\n")  # Log errors but continue
    })
  }
}

# Example Usage
#run_analysis_for_dyads(mea_normal, average_embedding, average_delay, "crqa_results_final.csv")
```

```{r}
crqa_df <- run_analysis_for_dyads(mea_normal, average_embedding, average_delay)
```

```{r-write-csv}
write.csv(crqa_df, "/Users/gabrielleyoung/Desktop/DataAP/crqa_results.csv", row.names = FALSE)
```

#```{r}
# Function to run CRQA on each dyad
run_crqa_for_dyad <- function(dyad_data, dyad_name, average_embedding, average_delay) {
  # Extract dyad number from the name
  dyad_number <- gsub("all_MEA_", "", dyad_name)  # Extract dyad number

  # Assuming the dataframe has columns for two participants
  ts_participant1 <- dyad_data[[1]]$Participant1  # Time series for Participant 1
  ts_participant2 <- dyad_data[[1]]$Participant2  # Time series for Participant 2

  # Extract the middle 60% of the time series data
  ts_participant1_middle <- get_middle_60_percent(ts_participant1)
  ts_participant2_middle <- get_middle_60_percent(ts_participant2)

  # Run CRQA analysis
  crqa_analysis <- crqa(ts1 = ts_participant1_middle, 
                         ts2 = ts_participant2_middle,
                         delay = average_delay,          # Use average_delay
                         embed = average_embedding,      # Use average_embedding
                         r = 0.1,                        # Adjust as needed
                         normalize = 0, 
                         rescale = 0, 
                         mindiagline = 2, 
                         minvertline = 2, 
                         tw = 0,                         # Theiler window (set as needed)
                         whiteline = FALSE, 
                         recpt = FALSE)

  # Create a named vector of results, including the dyad number
  results <- c(dyad_number = dyad_number, unlist(crqa_analysis[1:10]))  # Store dyad number and CRQA results
  return(results)
}

# Main analysis function for all dyads
run_analysis_for_all_dyads <- function(mea_normal, average_embedding, average_delay) {
  crqa_results <- vector("list", length(mea_normal))  # Preallocate list for results
  
  for (i in seq_along(mea_normal)) {  # Iterate over each dyad
    dyad_name <- names(mea_normal)[i]  # Get the dyad name from the list
    dyad_data <- mea_normal[[i]]        # Access the dyad data
    results <- run_crqa_for_dyad(dyad_data, dyad_name, average_embedding, average_delay)  # Run CRQA function for this dyad
    crqa_results[[i]] <- results  # Store the results
  }

  # Convert the list of results to a data frame
  crqa_df <- do.call(rbind, crqa_results)

  # Convert the columns to numeric if needed
  crqa_df <- as.data.frame(crqa_df, stringsAsFactors = FALSE)
  crqa_df[] <- lapply(crqa_df, as.numeric)

  return(crqa_df)
}

# Execute the analysis for all dyads and save to CSV
crqa_df <- run_analysis_for_all_dyads(mea_normal, average_embedding, average_delay)
write.csv(crqa_df, "crqa_results.csv", row.names = FALSE)
#```


#```{r function-to-csv}
# Define the function to process one dyad and return a named vector with the dyad number and results
run_crqa_for_dyad <- function(dyad_data, dyad_name) {
  # Extract dyad number from the name (assuming it follows "all_MEA_dyadnumber" format)
  dyad_number <- gsub("all_MEA_", "", dyad_name)  # Remove prefix to get the dyad number
  
  # Assuming the data frame has columns for two participants
  ts_participant1 <- na.omit(as.numeric(dyad_data$Participant1))  # Time series for Participant 1
  ts_participant2 <- na.omit(as.numeric(dyad_data$Participant2))  # Time series for Participant 2
  
  # Set CRQA parameters
  delay <- average_delay
  embed <- average_embedding
  radius <- 0.3  # Larger radius
  mindiagline <- 2  # Lower mindiagline
  minvertline <- 2
  tw <- 0
  whiteline <- FALSE
  recpt <- FALSE
  rescale <- 0
  normalize <- 0
  side <- "both"
  method <- 'mdcrqa'
  metric <- 'euclidean'
  datatype <- "continuous"
  
  # Take a small portion of time series for analysis
  ts_participant1_small <- ts_participant1[1:100]
  ts_participant2_small <- ts_participant2[1:100]
  
  # Apply smoothing
  ts_participant1_smoothed <- rollmean(ts_participant1_small, k = 5, fill = NA, align = "center")
  ts_participant2_smoothed <- rollmean(ts_participant2_small, k = 5, fill = NA, align = "center")
  
  # Clean any remaining NA values
  ts_participant1_clean <- na.omit(ts_participant1_smoothed)
  ts_participant2_clean <- na.omit(ts_participant2_smoothed)
  
  # Convert to matrices
  ts_participant1_matrix <- matrix(ts_participant1_clean, ncol = 1)
  ts_participant2_matrix <- matrix(ts_participant2_clean, ncol = 1)
  
  # Perform CRQA
  ans <- crqa(ts_participant1_matrix, ts_participant2_matrix, delay, embed, rescale, radius, normalize,
              mindiagline, minvertline, tw, whiteline, recpt, side, method, metric, datatype)
  
  # Create a named vector of results, adding dyad number as the first element
  results <- c(dyad_number = dyad_number, unlist(ans[1:10]))  # Store dyad number and CRQA results
  
  # Return the results vector
  return(results)
}

# Now, loop over all dyads in mea_normal, apply the function, and store results in a data frame
crqa_results <- lapply(names(mea_normal), function(dyad_name) {
  dyad_data <- mea_normal[[dyad_name]][[1]]  # Access the first datafile in each dyad
  run_crqa_for_dyad(dyad_data, dyad_name)    # Run the CRQA function and pass the dyad name
})

# Convert the list of results to a data frame
crqa_df <- do.call(rbind, crqa_results)

# Optionally, convert the columns to numeric if needed
crqa_df <- as.data.frame(crqa_df, stringsAsFactors = FALSE)
crqa_df[] <- lapply(crqa_df, as.numeric)

# Write the results to a CSV file
write.csv(crqa_df, "crqa_results.csv", row.names = FALSE)

# The CSV file "crqa_results.csv" will have the dyad number as the first column and CRQA metrics in the rest.
#```

#```{r}
# Define the function to process one dyad and return a named vector with the dyad number and results
run_crqa_for_dyad <- function(dyad_data, dyad_name) {
  # Extract dyad number from the name (assuming it follows "all_MEA_dyadnumber" format)
  dyad_number <- gsub("all_MEA_", "", dyad_name)  # Remove prefix to get the dyad number
  
  # Assuming the data frame has columns for two participants
  ts_participant1 <- na.omit(as.numeric(dyad_data$Participant1))  # Time series for Participant 1
  ts_participant2 <- na.omit(as.numeric(dyad_data$Participant2))  # Time series for Participant 2
  
  # Take a small portion of time series for analysis
  ts_participant1 <- get_middle_60_percent(ts_participant1)
  ts_participant2 <- get_middle_60_percent(ts_participant2)

  # Debugging output: Check lengths of time series
  cat("After middle 60% extraction - Dyad:", dyad_number, 
      " | Length Participant 1:", length(ts_participant1), 
      " | Length Participant 2:", length(ts_participant2), "\n")

  # Check for NA values
  if (any(is.na(ts_participant1)) || any(is.na(ts_participant2))) {
    warning(paste("NA values present in time series for dyad", dyad_number, ". Skipping this dyad."))
    return(NULL)  # Return NULL to skip this dyad
  }

  # Check if both time series are not empty and have the same length
  if (length(ts_participant1) == 0 || length(ts_participant2) == 0) {
    warning(paste("One of the time series for dyad", dyad_number, "is empty. Skipping this dyad."))
    return(NULL)  # Return NULL to skip this dyad
  }

  if (length(ts_participant1) != length(ts_participant2)) {
    warning(paste("Time series for dyad", dyad_number, "do not have the same length. Skipping this dyad."))
    return(NULL)  # Return NULL to skip this dyad
  }

  # Convert time series to matrices
  matrix_participant1 <- as.matrix(ts_participant1)
  matrix_participant2 <- as.matrix(ts_participant2)

  # Set CRQA parameters
  delay <- average_delay
  embed <- average_embedding
  radius <- 0.1  # Larger radius
  mindiagline <- 2  # Lower mindiagline
  minvertline <- 2
  tw <- 0
  whiteline <- FALSE
  recpt <- FALSE
  rescale <- 0
  normalize <- 0
  side <- "both"
  method <- 'mdcrqa'
  metric <- 'euclidean'
  datatype <- "continuous"

  # Perform CRQA
  cat("Calling CRQA - Dyad:", dyad_number, "\n")
  ans <- crqa(matrix_participant1, matrix_participant2, delay, embed, rescale, radius, normalize,
              mindiagline, minvertline, tw, whiteline, recpt, side, method, metric, datatype)

  # Create a named vector of results, adding dyad number as the first element
  results <- c(dyad_number = dyad_number, unlist(ans[1:10]))  # Store dyad number and CRQA results

  # Return the results vector
  return(results)
}

# Now, loop over all dyads in mea_normal, apply the function, and store results in a data frame
crqa_results <- lapply(names(mea_normal), function(dyad_name) {
  dyad_data <- mea_normal[[dyad_name]][[1]]  # Access the first datafile in each dyad
  run_crqa_for_dyad(dyad_data, dyad_name)    # Run the CRQA function and pass the dyad name
})

# Remove NULL results (skipped dyads)
crqa_results <- Filter(Negate(is.null), crqa_results)

# Convert the list of results to a data frame
crqa_df <- do.call(rbind, crqa_results)

# Optionally, convert the columns to numeric if needed
crqa_df <- as.data.frame(crqa_df, stringsAsFactors = FALSE) 
crqa_df[] <- lapply(crqa_df, as.numeric)

# Write the results to a CSV file
write.csv(crqa_df, "crqa_results.csv", row.names = FALSE)

#```

Displaying Time Series Data
```{r example-brown-bag-dyad-102}
path_normal102 <- read.table("/Users/gabrielleyoung/Desktop/DataAP/TxtFiles/MEA_video102.txt", quote="\"", comment.char="")
#mea_normal102 <- readMEA(path_normal102, sampRate = 25, s1Col = 1, s2Col = 2,
                   #  s1Name = "Participant1", s2Name = "Participant2", skip=1,
                    # idOrder = c("id","session"), idSep="_") 

#path_normal102 <- path_normal102 %>% filter(V1 <= 1000 & V2 <= 1000) 
path_normal102 <- as.numeric(path_normal102$V1)
output_file_path <- "/Users/gabrielleyoung/Desktop/DataAP/TxtFiles/MEA_video102.txt"

# Save the dataframe as a tab-delimited text file
write.table(path_normal102, file = output_file_path, sep = "\t", quote = FALSE, row.names = FALSE)


# Use the temporary file as input to readMEA function

mea_normal102 <- readMEA("/Users/gabrielleyoung/Desktop/DataAP/TxtFiles/MEA_video102.txt", sampRate = 25, s1Col = 1:1, s2Col = 2:2,
                        s1Name = "Participant1", s2Name = "Participant2", skip = 1,
                        idOrder = c("id", "session"), idSep = "_")


diagnosticPlot(mea_normal102[[1]])

mea_normal102_1 <- readMEA("/Users/gabrielleyoung/Desktop/DataAP/TxtFiles/MEA_video102.txt", sampRate = 25, s1Col = 1:1, s2Col = 1:1,
                        s1Name = "Participant1", s2Name = NA, skip = 1,
                        idOrder = c("id", "session"), idSep = "_")


mea_normal102_2 <- readMEA("/Users/gabrielleyoung/Desktop/DataAP/TxtFiles/MEA_video102.txt", sampRate = 25, s1Col = 2:2, s2Col = 2:2,
                        s1Name = NA, s2Name = "Participant2", skip = 1,
                        idOrder = c("id", "session"), idSep = "_")

diagnosticPlot(mea_normal102[[1]])
diagnosticPlot(mea_normal102_1[[1]])
diagnosticPlot(mea_normal102_2[[1]])
```


```{r crqa-dyad-102}
dyad102_data <- mea_normal[[3]] # this reflects the dyad order

# Assuming the dataframe has columns for two participants
dyad102_data2 <- dyad102_data[[1]] # this will always be 1
ts_participant1 <- dyad102_data2$Participant1  # Time series for Participant 1
ts_participant2 <- dyad102_data2$Participant2 

# ts_participant1s <- ts_participant1[4610:13829]
# ts_participant2s <- ts_participant2[4610:13829]

get_middle_60_percent <- function(time_series) {
  total_length <- length(time_series)  # Get the total length of the time series
  
  # Calculate the indices for the middle 60%
  start_index <- floor(0.2 * total_length) + 1  # Start after the first 20%
  end_index <- ceiling(0.8 * total_length)      # End before the last 20%
  
  # Select the middle 60% of the time series
  middle_60 <- time_series[start_index:end_index]
  
  return(middle_60)
}

ts_participant1s <- get_middle_60_percent(ts_participant1)
ts_participant2s <- get_middle_60_percent(ts_participant2)

cross_ami_p1 = mutual(ts_participant1s,
                 lag.max = 800)

cross_ami_p2 = mutual(ts_participant2s,
                     lag.max = 800)


find_first_minimum <- function(ami_values) {
  for (i in 2:(length(ami_values) - 1)) {
    if (ami_values[i] < ami_values[i - 1] && ami_values[i] < ami_values[i + 1]) {
      return(i)  # Return the lag corresponding to the first local minimum
    }
  }
  return(NULL)  # Return NULL if no minimum is found
}
# radius dyad 102
if (cross_rescale_type == 'mean'){
  rescaled_p1 = ts_participant1s / mean(ts_participant1s)
  rescaled_p2 = ts_participant2s / mean(ts_participant2s)
} else if (cross_rescale_type == 'max'){
  rescaled_p1 = ts_participant1s / max(ts_participant1s)
  rescaled_p2 = ts_participant2s / max(ts_participant2s)
}

crqa_analysis102 = crqa(ts1 = rescaled_p1, 
                    ts2 = rescaled_p2,
                    delay = average_delay, 
                    embed = average_embedding, 
                    r = .1, # you can keep playing with this to find something that works
                    normalize = 0, 
                    rescale = 0, # distance matrix rescaling option -- see documentation
                    mindiagline = 2,
                    minvertline = 2, 
                    tw = cross_theiler_window, 
                    whiteline = FALSE,
                    recpt=FALSE)
```

```{r}
#RESULTS FOR CRQA SAMPLE
crqa_analysis$RR # rate of recurrence
crqa_analysis$DET # % determinism
crqa_analysis$NRLINE # total number of lines on the plot
crqa_analysis$maxL # maximum line length on plot
crqa_analysis$L # average line length on plot
crqa_analysis$ENTR # entropy
crqa_analysis$rENTR # normalized entropy
crqa_analysis$LAM # laminarity
crqa_analysis$TT # trapping time
```
```{r export-results-csv}
# Create the data frame while checking for missing values
crqa_df <- data.frame(
  RR = ifelse(length(crqa_analysis$RR) > 0, crqa_analysis$RR, NA),
  DET = ifelse(length(crqa_analysis$DET) > 0, crqa_analysis$DET, NA),
  NRLINE = ifelse(length(crqa_analysis$NRLINE) > 0, crqa_analysis$NRLINE, NA),
  maxL = ifelse(length(crqa_analysis$maxL) > 0, crqa_analysis$maxL, NA),
  L = ifelse(length(crqa_analysis$L) > 0, crqa_analysis$L, NA),
  ENTR = ifelse(length(crqa_analysis$ENTR) > 0, crqa_analysis$ENTR, NA),
  rENTR = ifelse(length(crqa_analysis$rENTR) > 0, crqa_analysis$rENTR, NA),
  LAM = ifelse(length(crqa_analysis$LAM) > 0, crqa_analysis$LAM, NA),
  TT = ifelse(length(crqa_analysis$TT) > 0, crqa_analysis$TT, NA)
)

# Export the results to a CSV file
write.csv(crqa_df, file = "/Users/gabrielleyoung/Desktop/DataAP/crqa_results.csv", row.names = FALSE)

```

```{r}
crqa_df = data.frame(points = crqa_analysis$RP@i,
                           loc = seq_along(crqa_analysis$RP@i))
ggplot(crqa_df,aes(x=points,
                        y=loc)) +
  geom_point(color="black",size=.01) +
  theme_classic() +
  theme(legend.position="none", axis.text.x = element_blank(), axis.text.y = element_blank()) +
  ylab("Participant 2") + xlab("Participant 1") +
  ggtitle("Cross-recurrence plot between\nParticipant 1 and Participant 2 Movement in Survivor Task")
```
```

